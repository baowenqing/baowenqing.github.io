[{"title":"Handler引发内存泄漏","date":"2017-12-15T00:01:54.000Z","path":"/posts/技术/内存泄漏优化---Handler引发内存泄漏","text":"我们使用Handler的时候经常会有下面的提示： This Handler class should be static or leaks might occur 打开more：Since this Handler is declared as an inner class, it may prevent the outer class from being garbage collected. If the Handler is using a Looper or MessageQueue for a thread other than the main thread, then there is no issue. If the Handler is using the Looper or MessageQueue of the main thread, you need to fix your Handler declaration, as follows: Declare the Handler as a static class; In the outer class, instantiate a WeakReference to the outer class and pass this object to your Handler when you instantiate the Handler; Make all references to members of the outer class using the WeakReference object. 大概意思就是：一旦Handler被声明为内部类，那么可能导致它的外部类不能够被垃圾回收。如果Handler是在其他线程（我们通常成为worker thread）使用Looper或MessageQueue（消息队列），而不是main线程（UI线程），那么就没有这个问题。如果Handler使用Looper或MessageQueue在主线程（main thread），你需要对Handler的声明做如下修改：声明Handler为static类；在外部类中实例化一个外部类的WeakReference（弱引用）并且在Handler初始化时传入这个对象给你的Handler；将所有引用的外部类成员使用WeakReference对象。 方案一根据提示我们的方案是写一个继承Handler的内部类，在内部类的的构造方法中让Handler持有Activity的弱引用对象，代码如下： public class SplashActivity extends Activity { private SkipHandler handler = new SkipHandler(SplashActivity.this); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.layout_activity_splash); isFirstRun(); } /** * 方法描述：检测该应用是否是第一次运行 */ private void isFirstRun() { //检测是否是第一次运行该APP boolean isFirstRun = getSharedPreferences(&quot;FIRST_RUN&quot;, Context.MODE_PRIVATE).getBoolean(&quot;isFirstRun&quot;, true); if (isFirstRun) { handler.sendEmptyMessageDelayed(0, 1000); } else { handler.sendEmptyMessageDelayed(1, 2000); } } /** * 类描述：防止Handler造成Activity的内存泄漏 */ private static class SkipHandler extends Handler { WeakReference&lt;Activity&gt; mWeakActivity; /** * 方法描述：构造方法，Handler持有SplashActivity的弱引用对象 * @param activity */ public SkipHandler(Activity activity) { mWeakActivity = new WeakReference&lt;Activity&gt;(activity); } @Override public void handleMessage(Message msg) { super.handleMessage(msg); if (null != mWeakActivity) { SplashActivity mActivity = (SplashActivity) mWeakActivity.get(); switch (msg.what) { case 0: this.skipOtherActivity(mActivity, WelcomeActivity.class); break; case 1: this.skipOtherActivity(mActivity, HomeActivity.class); break; } } } /** * 方法描述：跳转到不同的Activity * * @param activity * @param cls */ private void skipOtherActivity(Activity activity, Class&lt;? extends Activity&gt; cls) { Intent intent = new Intent(activity, cls); activity.startActivity(intent); activity.finish(); } } } 方案二我们分析一下，有时候我们开启线程下载东西然后用Handler去更新UI，但是我们科恩个遇到这种情况：打开Activity然后又立即把Activity销毁，但此刻也许我们的工作线程然在执行下载的好事操作，而此刻Activity有执行destroy方法，但Handler一直持有Activity的对象从而导致Activity内存的泄漏。我们的解决方案可以是在Activity执行Destroy方法时停止工作线程，清空MessageQueue中所有的消息。","tags":[{"name":"内存泄漏优化","slug":"内存泄漏优化","permalink":"https://baowenqing.github.io/tags/内存泄漏优化/"}]},{"title":"Bugly热更新","date":"2017-12-14T03:01:54.000Z","path":"/posts/技术/Bugly热更新","text":"// 签名配置 123456789101112signingConfigs &#123; release &#123; try &#123; storeFile file(&quot;key.jks&quot;) storePassword &quot;******&quot; keyAlias &quot;key&quot; keyPassword &quot;******&quot; &#125; catch (ex) &#123; throw new InvalidUserDataException(ex.toString()) &#125; &#125;&#125; 必须要配置多渠道签名和热更新需要的 1234app.buildapply from: &apos;tinker-support.gradle&apos;// 多渠道使用walle示例（注：多渠道使用）apply plugin: &apos;walle&apos; 123456// 热更新 热升级 compile &quot;com.android.support:multidex:1.0.1&quot; // 多dex配置 compile &apos;com.tencent.bugly:crashreport_upgrade:1.3.1&apos;//其中latest.release指代最新版本号，也可以指定明确的版本号，例如1.2.0 compile &apos;com.tencent.bugly:nativecrashreport:latest.release&apos; //其中latest.release指代最新版本号，也可以指定明确的版本号，例如2.2.0 //瓦力的多渠道打包 compile &apos;com.meituan.android.walle:library:1.1.3&apos; 123456789walle &#123;// 打包执行的命令 gradlew clean assembleReleaseChannels // 指定渠道包的输出路径 apkOutputFolder = new File(&quot;$&#123;project.buildDir&#125;/outputs/channels&quot;); // 定制渠道包的APK的文件名称 apkFileNameFormat = &apos;$&#123;appName&#125;-$&#123;packageName&#125;-$&#123;channel&#125;-$&#123;buildType&#125;-v$&#123;versionName&#125;-$&#123;versionCode&#125;-$&#123;buildTime&#125;.apk&apos;; // 渠道配置文件 channelFile = new File(&quot;$&#123;project.getProjectDir()&#125;/channel&quot;)&#125; 项目.build 12345678910111213141516171819202122232425262728293031// tinkersupport插件, 其中lastest.release指拉取最新版本，也可以指定明确版本号，例如1.0.4classpath &quot;com.tencent.bugly:tinker-support:1.0.8&quot;classpath &apos;com.meituan.android.walle:plugin:1.1.3&apos;public class App extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); //设置是开发者的设备 Bugly.setIsDevelopmentDevice(getApplicationContext(),true); String channel = WalleChannelReader.getChannel(getApplication()); Bugly.setAppChannel(getApplication(), channel); Bugly.init(this, &quot;******&quot;, true); Beta.smallIconId = R.drawable.pikaqiu; Beta.defaultBannerId = R.drawable.pikaqiu; Beta.canShowUpgradeActs.add(MainActivity.class); Beta.storageDir = Environment. getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS); Beta.initDelay = 1 * 1000; Beta.autoInit = false; &#125; @Override protected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); // you must install multiDex whatever tinker is installed! MultiDex.install(base); // 安装tinker Beta.installTinker(); &#125;&#125; 这个是 正式版打包（目前上的基准包） 发布 补丁的话 要求 123456789101112里面的/*** 此处填写每次构建生成的基准包目录 新版本发布的时候 建议保存一份*/def baseApkDir = &quot;app-0630-13-26-10&quot;// 构建基准包和补丁包都要指定不同的tinkerId，并且必须保证唯一性tinkerId = &quot;1.0.4&quot;（唯一的一个名字就行 不用和项目的版本号一样）要更改安装正式包的 需要安装基带下的apk 或者用瓦力打包 瓦力打包下的 相当于加了基带修改需要改动的bug代码 执行buildAllFlavorsTinkerPatchRelease生成所有渠道补丁包 image 得到的patch文件夹的 7zip这个文件就是补丁啦","tags":[{"name":"热更新","slug":"热更新","permalink":"https://baowenqing.github.io/tags/热更新/"}]},{"title":"【转载】手把手教你建github技术博客","date":"2017-12-13T09:44:54.000Z","path":"/posts/技术/【转载】手把手教你建github技术博客","text":"@(标签)[github+hexo] 转载作者：吴小龙同學链接：https://www.jianshu.com/p/701b1095da11 适合人群 喜欢写Blog的人有一定的编程基础爱折腾的人熟练使用版本控制Git了解使用Github熟悉基本的MarkDown语法环境准备 安装Git安装Node.js在 Windows 环境下安装 Node.js 非常简单，仅须下载安装文件并执行即可完成安装。 安装hexo利用 npm 命令即可安装。（在任意位置点击鼠标右键，选择Git bash）npm install -g hexo问题 npm ERR! registry error parsing json 错误可能需要设置npm代理,执行命令 npm config set registry http://registry.cnpmjs.orghexo:command not found删除刚刚安装的npm目录，重新执行命令npm install -g hexo安装hexo，创建hexo文件夹 安装完成后，在你喜爱的文件夹下（如H:\\hexo），执行以下指令(在H:\\hexo内点击鼠标右键，选择Git bash)，Hexo 即会自动在目标文件夹建立网站所需要的所有文件。 hexo init安装依赖包 npm install本地查看 现在我们已经搭建起本地的hexo博客了，执行以下命令(在H:\\hexo)，然后到浏览器输入localhost:4000看看。 hexo generatehexo server好了，至此，本地博客已经搭建起来了，只是本地哦，别人看不到的。下面，我们要部署到Github。 问题 执行hexo server提示找不到该指令解决办法：在Hexo 3.0 后server被单独出来了，需要安装server，安装的命令如下：npm install hexo -server –save安装此server后再试，问题解决 github 创建博客注册账号 地址：https://github.com/输入账号、邮箱、密码,然后点击注册按钮. 创建页面仓库 这个仓库的名字需要和你的账号对应，格式: yourname.github.io输入基本信息，然后点击创建仓库. 注意命名规则：你的github账号.github.io，我这里被坑了，之前是jekell写的，现在换成hexo，所以我是另建创库了。生成SSH密钥 ssh-keygen -t rsa -C “你的邮箱地址”，按3个回车，密码为空。 在C:\\Users\\Administrator.ssh下，得到两个文件id_rsa和id_rsa.pub。 在GitHub上添加SSH密钥 打开id_rsa.pub，复制全文。https://github.com/settings/ssh ，Add SSH key，粘贴进去。 hexo使用 目录结构 .├── .deploy #需要部署的文件├── node_modules #Hexo插件├── public #生成的静态网页文件├── scaffolds #模板├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里| ├── _drafts #草稿| └── _posts #文章├── themes #主题├── _config.yml #全局配置文件└── package.json 全局配置 _config.yml Hexo Configuration Docs: http://hexo.io/docs/configuration.html Source: https://github.com/hexojs/hexo/ Site #站点信息title: #标题subtitle: #副标题description: #站点描述，给搜索引擎看的author: #作者email: #电子邮箱language: zh-CN #语言 URL #链接格式url: #网址root: / #根目录permalink: :year/:month/:day/:title/ #文章的链接格式tag_dir: tags #标签目录archive_dir: archives #存档目录category_dir: categories #分类目录code_dir: downloads/codepermalink_defaults: Directory #目录source_dir: source #源文件目录public_dir: public #生成的网页文件目录 Writing #写作new_post_name: :title.md #新文章标题default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）titlecase: false #标题转换成大写external_link: true #在新选项卡中打开连接filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsehighlight: #语法高亮 enable: true #是否启用 line_number: true #显示行号 tab_replace: Category &amp; Tag #分类和标签default_category: uncategorized #默认分类category_map:tag_map: Archives2: 开启分页1: 禁用分页0: 全部禁用archive: 2category: 2tag: 2 Server 本地服务器port: 4000 #端口号server_ip: localhost #IP 地址logger: falselogger_format: dev Date / Time format #日期时间格式date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/time_format: H:mm:ss Pagination 分页per_page: 10 #每页文章数，设置成 0 禁用分页pagination_dir: page Disqus Disqus评论，替换为多说disqus_shortname: Extensions 拓展插件theme: landscape-plus #主题exclude_generator:plugins: #插件，例如生成 RSS 和站点地图的 hexo-generator-feed hexo-generator-sitemapDeployment #部署，将 lmintlcx 改成用户名deploy:type: gitrepo: 刚刚github创库地址.gitbranch: master注意 配置文件的冒号“:”后面有一个空格repo: 刚刚github创库地址.githexo命令行使用 常用命令： hexo help #查看帮助hexo init #初始化一个目录hexo new “postName” #新建文章hexo new page “pageName” #新建页面hexo generate #生成网页，可以在 public 目录查看整个网站的文件hexo server #本地预览，’Ctrl+C’关闭hexo deploy #部署.deploy目录hexo clean #清除缓存，强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹简写： hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy编辑文章 新建文章 hexo new “标题”在 _posts 目录下会生成文件标题.md title: Hello Worlddate: 2015-07-30 07:56:29 #发表日期，一般不改动categories: hexo #文章文类 tags: [hexo,github] 文章标签，多于一项时用这种格式正文，使用Markdown语法书写编辑完后保存，hexo server 预览 hexo部署 执行下列指令即可完成部署。 hexo generatehexo deploy以下提示说明部署成功 [info] Deploy done: git点击 Github 上项目的 Settings，GitHub Pages，提示Your site is published at http://wuxiaolong.me (这是我买的域名) 图床 1.墙裂推荐七牛云储存,注册地址。 2.七牛云储存提供10G的免费空间,以及每月10G的流量.存放个人博客图片最好不过了 3.七牛云储存还有各种图形处理功能、缩略图、视频存放速度也给力（非打广告）。 具体使用见使用七牛作为github博客的图床 域名 将独立域名与GitHub Pages的空间绑定 方法一：在站点source目录下面，新建一个名为CNAME的文本文件，里面写入你要绑定的域名，比如wuxiaolong.me方法二：在Repository的根目录下面，新建一个名为CNAME的文本文件，里面写入你要绑定的域名，比如wuxiaolong.me DNS设置 用DNSpod，快，免费，稳定。注册DNSpod，添加域名，如下图设置。 其中A的两条记录指向的ip地址是github Pages的提供的ip如何知道你的github上项目的IP，如下： 去Godaddy修改DNS地址 更改godaddy的Nameservers为DNSpod的NameServers。 总结 之前用的jekell写的，手把手教你建github技术博客by jekyll，也是折腾了几天才做成自己满意的，昨天决定换成hexo，也是花了一天半时间，为了追求更好，必须折腾！","tags":[{"name":"hexo+github","slug":"hexo-github","permalink":"https://baowenqing.github.io/tags/hexo-github/"}]}]