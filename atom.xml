<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>文庆的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://baowenqing.github.io/"/>
  <updated>2017-12-15T09:48:01.424Z</updated>
  <id>https://baowenqing.github.io/</id>
  
  <author>
    <name>文庆</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Handler引发内存泄漏</title>
    <link href="https://baowenqing.github.io/2017/12/15/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%BC%98%E5%8C%96---Handler%E5%BC%95%E5%8F%91%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>https://baowenqing.github.io/2017/12/15/内存泄漏优化---Handler引发内存泄漏/</id>
    <published>2017-12-15T00:01:54.000Z</published>
    <updated>2017-12-15T09:48:01.424Z</updated>
    
    <content type="html"><![CDATA[<p>我们使用Handler的时候经常会有下面的提示：</p><h4 id="This-Handler-class-should-be-static-or-leaks-might-occur-打开more："><a href="#This-Handler-class-should-be-static-or-leaks-might-occur-打开more：" class="headerlink" title="This Handler class should be static or leaks might occur 打开more："></a>This Handler class should be static or leaks might occur 打开more：</h4><p>Since this Handler is declared as an inner class, it may prevent the outer class from being garbage collected. If the Handler is using a Looper or MessageQueue for a thread other than the main thread, then there is no issue. If the Handler is using the Looper or MessageQueue of the main thread, you need to fix your Handler declaration, as follows: Declare the Handler as a static class; In the outer class, instantiate a WeakReference to the outer class and pass this object to your Handler when you instantiate the Handler; Make all references to members of the outer class using the WeakReference object.</p><h4 id="大概意思就是："><a href="#大概意思就是：" class="headerlink" title="大概意思就是："></a>大概意思就是：</h4><p>一旦Handler被声明为内部类，那么可能导致它的外部类不能够被垃圾回收。如果Handler是在其他线程（我们通常成为worker thread）使用Looper或MessageQueue（消息队列），而不是main线程（UI线程），那么就没有这个问题。如果Handler使用Looper或MessageQueue在主线程（main thread），你需要对Handler的声明做如下修改：<br>声明Handler为static类；在外部类中实例化一个外部类的WeakReference（弱引用）并且在Handler初始化时传入这个对象给你的Handler；将所有引用的外部类成员使用WeakReference对象。</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>根据提示我们的方案是写一个继承Handler的内部类，在内部类的的构造方法中让Handler持有Activity的弱引用对象，代码如下：</p><pre><code>    public class SplashActivity extends Activity {      private SkipHandler handler = new SkipHandler(SplashActivity.this);      @Override      protected void onCreate(Bundle savedInstanceState) {          super.onCreate(savedInstanceState);          requestWindowFeature(Window.FEATURE_NO_TITLE);          setContentView(R.layout.layout_activity_splash);          isFirstRun();      }      /**       * 方法描述：检测该应用是否是第一次运行       */      private void isFirstRun() {          //检测是否是第一次运行该APP          boolean isFirstRun = getSharedPreferences(&quot;FIRST_RUN&quot;, Context.MODE_PRIVATE).getBoolean(&quot;isFirstRun&quot;, true);          if (isFirstRun) {              handler.sendEmptyMessageDelayed(0, 1000);          } else {              handler.sendEmptyMessageDelayed(1, 2000);          }      }      /**       * 类描述：防止Handler造成Activity的内存泄漏       */      private static class SkipHandler extends Handler {          WeakReference&lt;Activity&gt; mWeakActivity;          /**           * 方法描述：构造方法，Handler持有SplashActivity的弱引用对象           * @param activity           */          public SkipHandler(Activity activity) {              mWeakActivity = new WeakReference&lt;Activity&gt;(activity);          }          @Override          public void handleMessage(Message msg) {              super.handleMessage(msg);              if (null != mWeakActivity) {                  SplashActivity mActivity = (SplashActivity) mWeakActivity.get();                  switch (msg.what) {                      case 0:                          this.skipOtherActivity(mActivity, WelcomeActivity.class);                          break;                      case 1:                          this.skipOtherActivity(mActivity, HomeActivity.class);                          break;                  }              }          }          /**           * 方法描述：跳转到不同的Activity           *           * @param activity           * @param cls           */          private void skipOtherActivity(Activity activity, Class&lt;? extends Activity&gt; cls) {              Intent intent = new Intent(activity, cls);              activity.startActivity(intent);              activity.finish();          }      }  }</code></pre><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>我们分析一下，有时候我们开启线程下载东西然后用Handler去更新UI，但是我们科恩个遇到这种情况：打开Activity然后又立即把Activity销毁，但此刻也许我们的工作线程然在执行下载的好事操作，而此刻Activity有执行destroy方法，但Handler一直持有Activity的对象从而导致Activity内存的泄漏。<br>我们的解决方案可以是在Activity执行Destroy方法时停止工作线程，清空MessageQueue中所有的消息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们使用Handler的时候经常会有下面的提示：&lt;/p&gt;
&lt;h4 id=&quot;This-Handler-class-should-be-static-or-leaks-might-occur-打开more：&quot;&gt;&lt;a href=&quot;#This-Handler-class-shoul
      
    
    </summary>
    
      <category term="技术" scheme="https://baowenqing.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="内存泄漏优化" scheme="https://baowenqing.github.io/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Bugly热更新</title>
    <link href="https://baowenqing.github.io/2017/12/14/Bugly%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    <id>https://baowenqing.github.io/2017/12/14/Bugly热更新/</id>
    <published>2017-12-14T03:01:54.000Z</published>
    <updated>2017-12-15T09:48:09.986Z</updated>
    
    <content type="html"><![CDATA[<p>// 签名配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">signingConfigs &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            storeFile file(&quot;key.jks&quot;)</span><br><span class="line">            storePassword &quot;******&quot;</span><br><span class="line">            keyAlias &quot;key&quot;</span><br><span class="line">            keyPassword &quot;******&quot;</span><br><span class="line">        &#125; catch (ex) &#123;</span><br><span class="line">            throw new InvalidUserDataException(ex.toString())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须要配置<br>多渠道签名和热更新需要的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.build</span><br><span class="line">apply from: &apos;tinker-support.gradle&apos;</span><br><span class="line">// 多渠道使用walle示例（注：多渠道使用）</span><br><span class="line">apply plugin: &apos;walle&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//    热更新 热升级</span><br><span class="line">    compile &quot;com.android.support:multidex:1.0.1&quot; // 多dex配置</span><br><span class="line">    compile &apos;com.tencent.bugly:crashreport_upgrade:1.3.1&apos;//其中latest.release指代最新版本号，也可以指定明确的版本号，例如1.2.0</span><br><span class="line">    compile &apos;com.tencent.bugly:nativecrashreport:latest.release&apos; //其中latest.release指代最新版本号，也可以指定明确的版本号，例如2.2.0</span><br><span class="line">    //瓦力的多渠道打包</span><br><span class="line">    compile &apos;com.meituan.android.walle:library:1.1.3&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">walle &#123;</span><br><span class="line">//    打包执行的命令  gradlew clean assembleReleaseChannels</span><br><span class="line">    // 指定渠道包的输出路径</span><br><span class="line">    apkOutputFolder = new File(&quot;$&#123;project.buildDir&#125;/outputs/channels&quot;);</span><br><span class="line">    // 定制渠道包的APK的文件名称</span><br><span class="line">    apkFileNameFormat = &apos;$&#123;appName&#125;-$&#123;packageName&#125;-$&#123;channel&#125;-$&#123;buildType&#125;-v$&#123;versionName&#125;-$&#123;versionCode&#125;-$&#123;buildTime&#125;.apk&apos;;</span><br><span class="line">    // 渠道配置文件</span><br><span class="line">    channelFile = new File(&quot;$&#123;project.getProjectDir()&#125;/channel&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目.build</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// tinkersupport插件, 其中lastest.release指拉取最新版本，也可以指定明确版本号，例如1.0.4</span><br><span class="line">classpath &quot;com.tencent.bugly:tinker-support:1.0.8&quot;</span><br><span class="line">classpath &apos;com.meituan.android.walle:plugin:1.1.3&apos;</span><br><span class="line"></span><br><span class="line">public class App extends Application &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        //设置是开发者的设备</span><br><span class="line">        Bugly.setIsDevelopmentDevice(getApplicationContext(),true);</span><br><span class="line">        String channel = WalleChannelReader.getChannel(getApplication());</span><br><span class="line">        Bugly.setAppChannel(getApplication(), channel);</span><br><span class="line"></span><br><span class="line">        Bugly.init(this, &quot;******&quot;, true);</span><br><span class="line">        Beta.smallIconId = R.drawable.pikaqiu;</span><br><span class="line">        Beta.defaultBannerId  = R.drawable.pikaqiu;</span><br><span class="line">        Beta.canShowUpgradeActs.add(MainActivity.class);</span><br><span class="line">        Beta.storageDir = Environment.</span><br><span class="line">                getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS);</span><br><span class="line">        Beta.initDelay = 1 * 1000;</span><br><span class="line">        Beta.autoInit = false;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void attachBaseContext(Context base) &#123;</span><br><span class="line">        super.attachBaseContext(base);</span><br><span class="line">        // you must install multiDex whatever tinker is installed!</span><br><span class="line">        MultiDex.install(base);</span><br><span class="line">        // 安装tinker</span><br><span class="line">        Beta.installTinker();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是  正式版打包（目前上的基准包）</p><p>发布 补丁的话  要求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">里面的</span><br><span class="line">/**</span><br><span class="line">* 此处填写每次构建生成的基准包目录  新版本发布的时候 建议保存一份</span><br><span class="line">*/</span><br><span class="line">def baseApkDir = &quot;app-0630-13-26-10&quot;</span><br><span class="line"></span><br><span class="line">// 构建基准包和补丁包都要指定不同的tinkerId，并且必须保证唯一性</span><br><span class="line">tinkerId = &quot;1.0.4&quot;（唯一的一个名字就行 不用和项目的版本号一样）</span><br><span class="line">要更改</span><br><span class="line">安装正式包的  需要安装基带下的apk  或者用瓦力打包  瓦力打包下的 相当于加了基带</span><br><span class="line"></span><br><span class="line">修改需要改动的bug代码</span><br></pre></td></tr></table></figure><p><strong>执行buildAllFlavorsTinkerPatchRelease生成所有渠道补丁包</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://bugly.qq.com/docs/img/hotfix/android/Snip20170209_13.png?v=20170627170213" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure></p><p>得到的patch文件夹的  7zip这个文件就是补丁啦</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;// 签名配置&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;
      
    
    </summary>
    
      <category term="技术" scheme="https://baowenqing.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="热更新" scheme="https://baowenqing.github.io/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>【转载】手把手教你建github技术博客</title>
    <link href="https://baowenqing.github.io/2017/12/13/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%BB%BAgithub%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    <id>https://baowenqing.github.io/2017/12/13/【转载】手把手教你建github技术博客/</id>
    <published>2017-12-13T09:44:54.000Z</published>
    <updated>2017-12-15T09:48:17.099Z</updated>
    
    <content type="html"><![CDATA[<p>@(标签)[github+hexo]</p><blockquote><p>转载作者：吴小龙同學<br>链接：<a href="https://www.jianshu.com/p/701b1095da11" target="_blank" rel="noopener">https://www.jianshu.com/p/701b1095da11</a></p></blockquote><h3 id="适合人群"><a href="#适合人群" class="headerlink" title="适合人群"></a>适合人群</h3><blockquote><p>喜欢写Blog的人<br>有一定的编程基础<br>爱折腾的人<br>熟练使用版本控制Git<br>了解使用Github<br>熟悉基本的MarkDown语法<br>环境准备</p></blockquote><h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><h4 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h4><p>在 Windows 环境下安装 Node.js 非常简单，仅须下载安装文件并执行即可完成安装。</p><h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><h4 id="利用-npm-命令即可安装。（在任意位置点击鼠标右键，选择Git-bash）"><a href="#利用-npm-命令即可安装。（在任意位置点击鼠标右键，选择Git-bash）" class="headerlink" title="利用 npm 命令即可安装。（在任意位置点击鼠标右键，选择Git bash）"></a>利用 npm 命令即可安装。（在任意位置点击鼠标右键，选择Git bash）</h4><h4 id="npm-install-g-hexo"><a href="#npm-install-g-hexo" class="headerlink" title="npm install -g hexo"></a>npm install -g hexo</h4><p>问题</p><p>npm ERR! registry error parsing json 错误<br>可能需要设置npm代理,执行命令</p><p>npm config set registry <a href="http://registry.cnpmjs.org" target="_blank" rel="noopener">http://registry.cnpmjs.org</a><br>hexo:command not found<br>删除刚刚安装的npm目录，重新执行命令npm install -g hexo安装hexo，<br>创建hexo文件夹</p><p>安装完成后，在你喜爱的文件夹下（如H:\hexo），执行以下指令(在H:\hexo内点击鼠标右键，选择Git bash)，Hexo 即会自动在目标文件夹建立网站所需要的所有文件。</p><h4 id="hexo-init"><a href="#hexo-init" class="headerlink" title="hexo init"></a>hexo init</h4><p>安装依赖包</p><h4 id="npm-install"><a href="#npm-install" class="headerlink" title="npm install"></a>npm install</h4><p>本地查看</p><p>现在我们已经搭建起本地的hexo博客了，执行以下命令(在H:\hexo)，然后到浏览器输入localhost:4000看看。</p><h4 id="hexo-generate"><a href="#hexo-generate" class="headerlink" title="hexo generate"></a>hexo generate</h4><h4 id="hexo-server"><a href="#hexo-server" class="headerlink" title="hexo server"></a>hexo server</h4><p>好了，至此，本地博客已经搭建起来了，只是本地哦，别人看不到的。下面，我们要部署到Github。</p><p>问题</p><p>执行hexo server提示找不到该指令<br>解决办法：<br>在Hexo 3.0 后server被单独出来了，需要安装server，安装的命令如下：<br>npm install hexo -server –save<br>安装此server后再试，问题解决</p><h4 id="github-创建博客"><a href="#github-创建博客" class="headerlink" title="github 创建博客"></a>github 创建博客</h4><p>注册账号</p><p>地址：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a><br>输入账号、邮箱、密码,然后点击注册按钮.</p><p>创建页面仓库</p><p>这个仓库的名字需要和你的账号对应，格式: yourname.github.io<br>输入基本信息，然后点击创建仓库.</p><p>注意<br>命名规则：你的github账号.github.io，我这里被坑了，之前是jekell写的，现在换成hexo，所以我是另建创库了。<br>生成SSH密钥</p><p>ssh-keygen -t rsa -C “你的邮箱地址”，按3个回车，密码为空。</p><p>在C:\Users\Administrator.ssh下，得到两个文件id_rsa和id_rsa.pub。</p><p>在GitHub上添加SSH密钥</p><p>打开id_rsa.pub，复制全文。<a href="https://github.com/settings/ssh" target="_blank" rel="noopener">https://github.com/settings/ssh</a> ，Add SSH key，粘贴进去。</p><p>hexo使用</p><p>目录结构</p><p>.<br>├── .deploy #需要部署的文件<br>├── node_modules #Hexo插件<br>├── public #生成的静态网页文件<br>├── scaffolds #模板<br>├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里<br>| ├── _drafts #草稿<br>| └── _posts #文章<br>├── themes #主题<br>├── _config.yml #全局配置文件<br>└── package.json</p><h4 id="全局配置-config-yml"><a href="#全局配置-config-yml" class="headerlink" title="全局配置 _config.yml"></a>全局配置 _config.yml</h4><p> Hexo Configuration<br> Docs: <a href="http://hexo.io/docs/configuration.html" target="_blank" rel="noopener">http://hexo.io/docs/configuration.html</a><br> Source: <a href="https://github.com/hexojs/hexo/" target="_blank" rel="noopener">https://github.com/hexojs/hexo/</a><br> Site #站点信息<br>title:  #标题<br>subtitle:  #副标题<br>description:  #站点描述，给搜索引擎看的<br>author:  #作者<br>email:  #电子邮箱<br>language: zh-CN #语言</p><h3 id="URL-链接格式"><a href="#URL-链接格式" class="headerlink" title="URL #链接格式"></a>URL #链接格式</h3><p>url:  #网址<br>root: / #根目录<br>permalink: :year/:month/:day/:title/ #文章的链接格式<br>tag_dir: tags #标签目录<br>archive_dir: archives #存档目录<br>category_dir: categories #分类目录<br>code_dir: downloads/code<br>permalink_defaults:</p><h3 id="Directory-目录"><a href="#Directory-目录" class="headerlink" title="Directory #目录"></a>Directory #目录</h3><p>source_dir: source #源文件目录<br>public_dir: public #生成的网页文件目录</p><h3 id="Writing-写作"><a href="#Writing-写作" class="headerlink" title="Writing #写作"></a>Writing #写作</h3><p>new_post_name: :title.md #新文章标题<br>default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）<br>titlecase: false #标题转换成大写<br>external_link: true #在新选项卡中打开连接<br>filename_case: 0<br>render_drafts: false<br>post_asset_folder: false<br>relative_link: false<br>highlight: #语法高亮<br>  enable: true #是否启用<br>  line_number: true #显示行号<br>  tab_replace:</p><h3 id="Category-amp-Tag-分类和标签"><a href="#Category-amp-Tag-分类和标签" class="headerlink" title="Category &amp; Tag #分类和标签"></a>Category &amp; Tag #分类和标签</h3><p>default_category: uncategorized #默认分类<br>category_map:<br>tag_map:</p><h3 id="Archives"><a href="#Archives" class="headerlink" title="Archives"></a>Archives</h3><p>2: 开启分页<br>1: 禁用分页<br>0: 全部禁用<br>archive: 2<br>category: 2<br>tag: 2</p><h3 id="Server-本地服务器"><a href="#Server-本地服务器" class="headerlink" title="Server 本地服务器"></a>Server 本地服务器</h3><p>port: 4000 #端口号<br>server_ip: localhost #IP 地址<br>logger: false<br>logger_format: dev</p><h3 id="Date-Time-format-日期时间格式"><a href="#Date-Time-format-日期时间格式" class="headerlink" title="Date / Time format #日期时间格式"></a>Date / Time format #日期时间格式</h3><p>date_format: YYYY-MM-DD #参考<a href="http://momentjs.com/docs/#/displaying/format/" target="_blank" rel="noopener">http://momentjs.com/docs/#/displaying/format/</a><br>time_format: H:mm:ss</p><h3 id="Pagination-分页"><a href="#Pagination-分页" class="headerlink" title="Pagination 分页"></a>Pagination 分页</h3><p>per_page: 10 #每页文章数，设置成 0 禁用分页<br>pagination_dir: page</p><h3 id="Disqus-Disqus评论，替换为多说"><a href="#Disqus-Disqus评论，替换为多说" class="headerlink" title="Disqus Disqus评论，替换为多说"></a>Disqus Disqus评论，替换为多说</h3><p>disqus_shortname:</p><h3 id="Extensions-拓展插件"><a href="#Extensions-拓展插件" class="headerlink" title="Extensions 拓展插件"></a>Extensions 拓展插件</h3><p>theme: landscape-plus #主题<br>exclude_generator:<br>plugins: #插件，例如生成 RSS 和站点地图的</p><ul><li>hexo-generator-feed</li><li>hexo-generator-sitemap<h3 id="Deployment-部署，将-lmintlcx-改成用户名"><a href="#Deployment-部署，将-lmintlcx-改成用户名" class="headerlink" title="Deployment #部署，将 lmintlcx 改成用户名"></a>Deployment #部署，将 lmintlcx 改成用户名</h3>deploy:<br>type: git<br>repo: 刚刚github创库地址.git<br>branch: master<br>注意</li></ul><p>配置文件的冒号“:”后面有一个空格<br>repo: 刚刚github创库地址.git<br>hexo命令行使用</p><p>常用命令：</p><p>hexo help #查看帮助<br>hexo init #初始化一个目录<br>hexo new “postName” #新建文章<br>hexo new page “pageName” #新建页面<br>hexo generate #生成网页，可以在 public 目录查看整个网站的文件<br>hexo server #本地预览，’Ctrl+C’关闭<br>hexo deploy #部署.deploy目录<br>hexo clean #清除缓存，<strong>强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹</strong><br>简写：</p><p>hexo n == hexo new<br>hexo g == hexo generate<br>hexo s == hexo server<br>hexo d == hexo deploy<br>编辑文章</p><p>新建文章</p><p>hexo new “标题”<br>在 _posts 目录下会生成文件标题.md</p><p>title: Hello World<br>date: 2015-07-30 07:56:29 #发表日期，一般不改动<br>categories: hexo #文章文类</p><h2 id="tags-hexo-github-文章标签，多于一项时用这种格式"><a href="#tags-hexo-github-文章标签，多于一项时用这种格式" class="headerlink" title="tags: [hexo,github] 文章标签，多于一项时用这种格式"></a>tags: [hexo,github] 文章标签，多于一项时用这种格式</h2><p>正文，使用Markdown语法书写<br>编辑完后保存，hexo server 预览</p><p>hexo部署</p><p>执行下列指令即可完成部署。</p><p>hexo generate<br>hexo deploy<br>以下提示说明部署成功</p><p>[info] Deploy done: git<br>点击 Github 上项目的 Settings，GitHub Pages，提示Your site is published at <a href="http://wuxiaolong.me" target="_blank" rel="noopener">http://wuxiaolong.me</a> (这是我买的域名)</p><p>图床</p><p>1.墙裂推荐七牛云储存,注册地址。</p><p>2.七牛云储存提供10G的免费空间,以及每月10G的流量.存放个人博客图片最好不过了</p><p>3.七牛云储存还有各种图形处理功能、缩略图、视频存放速度也给力（非打广告）。</p><p>具体使用见使用七牛作为github博客的图床</p><p>域名</p><p>将独立域名与GitHub Pages的空间绑定</p><p>方法一：在站点source目录下面，新建一个名为CNAME的文本文件，里面写入你要绑定的域名，比如wuxiaolong.me<br>方法二：在Repository的根目录下面，新建一个名为CNAME的文本文件，里面写入你要绑定的域名，比如wuxiaolong.me</p><p>DNS设置</p><p>用DNSpod，快，免费，稳定。<br>注册DNSpod，添加域名，如下图设置。</p><p>其中A的两条记录指向的ip地址是github Pages的提供的ip<br>如何知道你的github上项目的IP，如下：</p><p>去Godaddy修改DNS地址</p><p>更改godaddy的Nameservers为DNSpod的NameServers。</p><p>总结</p><p>之前用的jekell写的，手把手教你建github技术博客by jekyll，也是折腾了几天才做成自己满意的，昨天决定换成hexo，也是花了一天半时间，为了追求更好，必须折腾！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@(标签)[github+hexo]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;转载作者：吴小龙同學&lt;br&gt;链接：&lt;a href=&quot;https://www.jianshu.com/p/701b1095da11&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;h
      
    
    </summary>
    
      <category term="技术" scheme="https://baowenqing.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="hexo+github" scheme="https://baowenqing.github.io/tags/hexo-github/"/>
    
  </entry>
  
</feed>
